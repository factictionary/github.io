<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Falling Merge — Fixed Merging</title>
<meta name="robots" content="index, follow">
<link rel="stylesheet" href="common.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --board-size:100px; --gap:8px; --panel: rgba(30,30,46,0.85);
  --accent: linear-gradient(90deg,#4ade80,#22d3ee);
  --cell-radius:12px;
}
.game-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
	background: rgba(0, 0, 0, 0.95);
}

*{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
.app{ 
    width: 100%; 
    display:flex; 
    gap: 20px; 
    align-items:flex-start; 
    flex-wrap:wrap; 
    justify-content: center;
}
.left{ 
    flex: 1; 
    min-width: 400px; 
    max-width: 500px;
}
.panel{ 
    background: var(--panel); 
    padding:12px; 
    border-radius:12px; 
    box-shadow:0 8px 30px rgba(3,7,18,0.6); 
    color: #e6eef6; /* Ensure text is visible */
}
.info{ display:flex; gap:12px; align-items:center; font-weight:700; }
.info div{ min-width:84px; text-align:center; font-size:0.95rem; color: #e6eef6; }
.board-wrap{ margin-top:12px; display:flex; gap:12px; align-items:center; justify-content:center; }
.board{ 
    width:100%; 
    max-width:420px; 
    aspect-ratio:5/8; 
    display:grid; 
    gap:4px; 
    padding:2px; 
    border-radius:10px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); 
    border: 1px solid rgba(255,255,255,0.03);
    box-shadow: inset 0 8px 30px rgba(0,0,0,0.7);
}
.right{ 
    flex: 0 0 260px; 
    display:flex; 
    flex-direction:column; 
    gap:12px; 
}
.next-tile{ height:96px; display:flex; align-items:center; justify-content:center; border-radius:10px; background:rgba(255,255,255,0.02); }
.legend{ display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:8px; }
.sw{ height:38px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:800; }
.cell{ aspect-ratio:1/1; border-radius: var(--cell-radius); display:flex; align-items:center; justify-content:center; font-weight:800;
  transition: transform .12s ease, box-shadow .18s ease, background .18s ease; user-select:none; color: #06201f; /* Ensure text is visible */ }
.cell.empty{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: inset 0 2px 0 rgba(255,255,255,0.02);}
.cell.big{ font-size:0.95rem; padding:2px 6px; }
.pop{ animation: pop .32s ease; }
@keyframes pop {0%{transform:scale(.85)}50%{transform:scale(1.16)}100%{transform:scale(1)}}
.controls-row{ display:flex; gap:10px; margin-top:12px; justify-content:center; flex-wrap:wrap; }
button{ background:var(--accent); color:#022; border:none; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer; box-shadow:0 8px 18px rgba(34,211,238,0.06); }
.btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--ui-text,#e6eef6); padding:8px 12px; }
.footer{ margin-top:12px; text-align:center; color:#9fb3c6; font-size:0.9rem; }
.setting-row{ display:flex; gap:8px; align-items:center; justify-content:space-between; color: #e6eef6; }
select,input[type=checkbox]{ padding:6px 8px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.04); color:inherit; }
.theme-darkneon{ --panel: rgba(5,6,16,0.9); --accent: linear-gradient(90deg,#06b6d4,#8b5cf6); color:#e6eef6;}
.theme-light{ --panel: #f5f5f2; --accent: linear-gradient(90deg,#f59e0b,#f97316); color:#222; }
.theme-pastel{ --panel: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85)); --accent: linear-gradient(90deg,#f472b6,#60a5fa); color:#10273f;}

/* Header styles */
#header-container {
    width: 100%;
    margin-bottom: 0px;
	padding: 0px 0;
    color: #000000 !important; /* Force white text */
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7); /* Add text shadow for better contrast */
}

/* Ensure header text is visible */
#header-container h1,
#header-container h2,
#header-container h3,
#header-container .subtitle,
#header-container .tagline {
    color: #000000 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
}

/* Make sure all text in the game header is visible */
header h1 {
    color: #000000 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
    font-size: 1.5rem;
    margin-bottom: 0px;
}

header .sub {
    color: rgba(0, 0, 0, 0.5) !important;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
    font-size: 1.1rem;
}

/* Update the panel text colors to ensure visibility */
.panel {
    background: var(--panel); 
    padding: 12px; 
    border-radius: 2px; 
    box-shadow: 0 8px 30px rgba(3, 7, 18, 0.6); 
    color: #ffffff !important; /* Force white text in panels */
}

.info div {
    min-width: 84px; 
    text-align: center; 
    font-size: 0.95rem; 
    color: #ffffff !important; /* Force white text */
}

/* Ensure score numbers are visible */
#score, #best, #level {
    color: #ffffff !important;
    font-weight: 800;
    font-size: 1.2rem;
}

/* Ensure all text is visible in dark theme */
h1, .sub, .footer, .panel div {
    color: inherit;
	margin-left: 10px;
	margin-left: 10px;
}

/* Tile styling (adjust to match your game's tile class) */
.tile {
  position: relative;
  width: 100px; /* Adjust based on your grid */
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #cdc1b4;
  border-radius: 8px;
  font-size: 24px;
  font-weight: bold;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  color: #06201f; /* Ensure text is visible */
}

/* Pop animation: scale up and down with color pulse */
.pop {
  animation: pop 0.4s ease;
}

@keyframes pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); background-color: #ffeb3b; }
  100% { transform: scale(1); }
}

/* Glow effect: pulsating border */
.glow {
  animation: glow 0.6s ease;
}

@keyframes glow {
  0% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
  50% { box-shadow: 0 0 20px 5px rgba(255, 215, 0, 0.8); }
  100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
}

/* Particle effect: small dots bursting outward */
.particle {
  position: absolute;
  width: 8px;
  height: 8px;
  background-color: #ff5722;
  border-radius: 50%;
  pointer-events: none;
  animation: particle-burst 0.6s ease forwards;
}

@keyframes particle-burst {
  0% {
    transform: translate(0, 0);
    opacity: 1;
  }
  100% {
    transform: translate(var(--tx), var(--ty));
    opacity: 0;
  }
}

/* Responsive design */
@media (max-width: 768px){
  .app{ 
    flex-direction: column; 
    align-items: center; 
  } 
  .left, .right{ 
    width: 100%; 
    max-width: 100%;
  }
  .game-container {
    padding: 10px;
  }
}

/* Improved movement animations */
/* Reduced padding between cells */
.board {
    width: 100%;
    max-width: 320px;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 4px; /* Reduced from 8px to 4px */
    padding: 8px; /* Reduced from 12px to 8px */
    border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.03);
    box-shadow: inset 0 8px 30px rgba(0,0,0,0.7);
    margin: 0 auto;
}

.cell {
    width: 100%;
    height: 100%;
    border-radius: 10px; /* Slightly smaller radius to match reduced gap */
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    transition: all 0.15s ease;
    user-select: none;
    color: #06201f;
    font-size: 18px;
    min-height: 0;
    min-width: 0;
}

.cell.empty {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); /* Reduced shadow */
}

/* Tile content styling */
.cell:not(.empty) {
    font-size: clamp(14px, 4vw, 20px);
    font-weight: 900;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.cell.big {
    font-size: clamp(12px, 3vw, 16px);
    padding: 1px 2px; /* Reduced padding */
}

/* Button hover and active states */
button {
    background: var(--accent); 
    color:#022; 
    border:none; 
    padding:10px 14px; 
    border-radius:10px; 
    font-weight:800; 
    cursor:pointer; 
    box-shadow:0 8px 18px rgba(34,211,238,0.06);
    transition: all 0.1s ease;
    transform: scale(1);
}

button:hover {
    transform: scale(1.05);
    box-shadow: 0 12px 24px rgba(34,211,238,0.12);
}

button:active {
    transform: scale(0.95);
}

/* Movement direction indicators */
.moving-left { transform: translateX(-3px) scale(0.98); }
.moving-right { transform: translateX(3px) scale(0.98); }
.moving-down { transform: translateY(3px) scale(0.98); }

/* Quick flash effect for movement */
@keyframes quickFlash {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.quick-flash {
    animation: quickFlash 0.1s ease;
}

</style>
</head>
<body>
	<!-- Include common header -->
	<div id="header-container"></div>
	<div class="game-container">

	  <div id="app" class="app theme-darkneon">
		<div class="left">
		  <header>
			<div>
			  <h1>Falling Merge</h1>
			  <div class="sub" style="color:inherit; opacity:.85; font-weight:600;">Merge equal neighbors. Create the biggest tile!</div>
			</div>
			<div class="controls-top">
			  <div class="panel info" style="min-width:220px;">
				<div>Score<br><span id="score">0</span></div>
				<div>Best<br><span id="best">2</span></div>
				<div>Level<br><span id="level">1</span></div>
			  </div>
			</div>
		  </header>

		  <div class="board-wrap panel" style="margin-top:10px;">
			<div id="board" class="board" aria-label="game board"></div>
		  </div>

		  <div class="controls-row">
			<button id="leftBtn" title="Move left">◀</button>
			<button id="downBtn" title="Soft drop">▼</button>
			<button id="rightBtn" title="Move right">▶</button>
			<button id="hardBtn" title="Hard drop (Enter)">⇩</button>
			<button id="pauseBtn" class="btn-ghost">Pause</button>
			<button id="restartBtn" class="btn-ghost">New Game</button>
		  </div>

		  <div class="footer">Controls: ← → move, ↓ soft drop, Enter hard drop, Space pause.</div>
		</div>

		<div class="right">
		  <div class="panel">
			<div style="font-weight:800;margin-bottom:6px;">Next Tile</div>
			<div id="next" class="next-tile"></div>

			<div style="margin-top:12px;" class="setting-row">
			  <div style="font-weight:700;">Theme</div>
			  <select id="themeSelector">
				<option value="darkneon">Dark Neon</option>
				<option value="light">Classic Light</option>
				<option value="pastel">Pastel</option>
			  </select>
			</div>

			<div style="margin-top:12px;" class="setting-row">
			  <div style="font-weight:700;">Sound</div>
			  <label style="display:flex;align-items:center;gap:8px;"><input id="soundToggle" type="checkbox" checked/> On</label>
			</div>
		  </div>

		  <div class="panel">
			<div style="font-weight:800;">Legend</div>
			<div class="legend" id="legendPreview"></div>
			<div style="margin-top:8px;color:var(--ui-muted, #9fb3c6); font-size:0.92rem;">
			  Larger tiles unlock as you build higher numbers — faster and more exciting drops.
			</div>
		  </div>

		  <div class="panel" style="text-align:center;">
			<div style="font-weight:800;margin-bottom:8px;">Tips</div>
			<div style="color:#9fb3c6; font-size:0.92rem;">
			  Build a strong stack and feed it matching tiles. Unlock larger falling tiles to accelerate merges.
			</div>
		  </div>
		</div>
	</div>

<script>
// Load common header
fetch('header.html')
    .then(response => response.text())
    .then(data => {
        document.getElementById('header-container').innerHTML = data;
    });
	
/* ---------- CONFIG ---------- */
const ROWS = 8, COLS = 5;
const BASE_SPEED = 700;
const LEVEL_SCORE_STEP = 1000;

/* ---------- STATE ---------- */
let grid = [];
let falling = null; // {row,col,val}
let nextTile = null;
let score = 0, bestTile = 2, level = 1, speed = BASE_SPEED;
let fallTimer = null, paused = false, gameOver = false, soundEnabled = true;

/* dynamic pool with rate limiting */
const basePool = [2,4,8,16,32,64];
let availableTiles = [...basePool];
let tileCooldowns = {}; // Track when tiles were last used

/* ---------- DOM ---------- */
const appEl = document.getElementById('app');
const boardEl = document.getElementById('board');
const nextEl = document.getElementById('next');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const levelEl = document.getElementById('level');
const legendEl = document.getElementById('legendPreview');

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const downBtn = document.getElementById('downBtn');
const hardBtn = document.getElementById('hardBtn');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const themeSelector = document.getElementById('themeSelector');
const soundToggle = document.getElementById('soundToggle');

/* ---------- AUDIO ---------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
function playTone(freq, time=0.08, type='sine', gain=0.08){
  if(!soundEnabled) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + time);
}
function playMergeSound(){ playTone(880, 0.12, 'sine', 0.10); }
function playGameOver(){ playTone(160, 0.3, 'sine', 0.18); playTone(220, 0.18, 'sine', 0.12); }

/* ---------- COLORS ---------- */
function colorForValue(v){
  const map = {
    2: '#FF6B6B',     // Bright Red
    4: '#4ECDC4',     // Teal
    8: '#FFD166',     // Yellow
    16: '#06D6A0',    // Green
    32: '#118AB2',    // Blue
    64: '#073B4C',    // Dark Blue
    128: '#7209B7',   // Purple
    256: '#F15BB5',   // Pink
    512: '#FF9E00',   // Orange
    1024: '#00BBF9',  // Light Blue
    2048: '#FF006E'   // Magenta
  };
  return map[v] || '#333333';
}

/* ---------- UI BUILD ---------- */
function buildBoardUI(){
  boardEl.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
  boardEl.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
  boardEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell empty';
      cell.dataset.r = r; cell.dataset.c = c;
      boardEl.appendChild(cell);
    }
  }
}
function getCellEl(r,c){ return boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }
function updateLegend(){
  legendEl.innerHTML = '';
  [2,4,8,16,32,64,128,256].forEach(v=>{
    const sw = document.createElement('div'); sw.className = 'sw'; sw.textContent = v;
    sw.style.background = colorForValue(v); 
    sw.style.color = (v<=32)?'#06201f':'#fff'; // Ensure text is visible
    legendEl.appendChild(sw);
  });
}

/* ---------- GRID HELPERS ---------- */
function resetGrid(){ grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0)); }
function render(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const v = grid[r][c]; const el = getCellEl(r,c);
      if(!el) continue;
      if(v === 0){ el.className='cell empty'; el.textContent=''; el.style.background=''; el.style.color='';}
      else { 
        el.className='cell'; 
        el.textContent=v; 
        el.style.background=colorForValue(v);
        // Ensure text is visible based on tile value
        el.style.color = (v<=32)?'#06201f':'#fff'; 
        el.classList.toggle('big', v>=1024); 
      }
    }
  }
}

/* ---------- DYNAMIC POOL WITH RATE LIMITING ---------- */
function updateAvailableTiles(){
  availableTiles = [...basePool];
  const unlocks = [{th:2048, add:128}, {th:8192, add:256}, {th:16384, add:512}, {th:32768, add:1024}];
  for(const u of unlocks) if(bestTile >= u.th && !availableTiles.includes(u.add)) availableTiles.push(u.add);
}

function makeWeightedPool(){
  updateAvailableTiles();
  const pool = [];
  const now = Date.now();
  
  // Rate limiting: don't show the same tile too frequently
  for(const v of availableTiles){
    const lastUsed = tileCooldowns[v] || 0;
    const timeSinceLastUse = now - lastUsed;
    
    // Higher values have shorter cooldowns to encourage progression
    let cooldownTime = 3000; // 3 seconds base cooldown
    if (v >= 128) cooldownTime = 2000;
    if (v >= 512) cooldownTime = 1500;
    if (v >= 1024) cooldownTime = 1000;
    
    // If this tile was used recently, reduce its weight
    let weight = 6 / Math.log2(Math.max(v,2));
    if (timeSinceLastUse < cooldownTime) {
      // Reduce weight if used recently (more reduction for smaller values)
      const reduction = v <= 8 ? 0.3 : 0.6;
      weight *= reduction;
    }
    
    if(v >= 128) weight *= (Math.log2(v)/6);
    const count = Math.max(1, Math.round(weight));
    for(let i=0;i<count;i++) pool.push(v);
  }
  
  return pool;
}

function pickNextFromPool(){ 
  const pool = makeWeightedPool(); 
  const selected = pool[Math.floor(Math.random()*pool.length)];
  
  // Update cooldown for the selected tile
  tileCooldowns[selected] = Date.now();
  
  return selected;
}

/* ---------- SPAWN ---------- */
function spawnNextTile(){ 
  nextTile = pickNextFromPool(); 
  nextEl.innerHTML=''; 
  const box=document.createElement('div');
  box.style.width='72px'; 
  box.style.height='72px'; 
  box.style.borderRadius='10px'; 
  box.style.display='flex';
  box.style.alignItems='center'; 
  box.style.justifyContent='center'; 
  box.style.fontWeight='900'; 
  box.style.fontSize='1.25rem';
  box.style.background = colorForValue(nextTile); 
  box.style.color = (nextTile<=32)?'#06201f':'#fff'; // Ensure text is visible
  box.textContent = nextTile;
  nextEl.appendChild(box);
}

function spawnFalling(){
  if(gameOver) return;
  if(nextTile === null) spawnNextTile();
  const center = Math.floor(COLS/2);
  const order = [];
  for(let d=0; d<COLS; d++){
    const left = center - d; const right = center + d;
    if(left >= 0) order.push(left);
    if(right !== left && right < COLS) order.push(right);
  }
  let col = -1;
  for(const c of order) if(grid[0][c] === 0) { col = c; break; }
  if(col === -1){ endGame(); return; }
  const val = nextTile; nextTile = null; spawnNextTile();
  grid[0][col] = val; falling = {row:0, col, val}; render();
}

/* ---------- MOVEMENT ---------- */
/* ---------- OPTIMIZED MOVEMENT ---------- */
let lastMoveTime = 0;
const MOVE_COOLDOWN = 100; // milliseconds between moves
let keysPressed = {};

function canMoveDown(){ 
    if(!falling) return false; 
    const {row,col} = falling; 
    return (row < ROWS-1 && grid[row+1][col] === 0); 
}

function advanceFall(){
    if(!falling || paused || gameOver) return;
    const {row,col,val} = falling;
    if(canMoveDown()){
        grid[row][col] = 0; 
        grid[row+1][col] = val; 
        falling.row++; 
        render();
        // Visual feedback for movement
        const cell = getCellEl(falling.row, falling.col);
        if(cell) cell.style.transform = 'scale(0.95)';
        setTimeout(() => {
            if(cell) cell.style.transform = 'scale(1)';
        }, 100);
    } else {
        const landedRow = row, landedCol = col;
        falling = null;
        processLand(landedRow, landedCol);
    }
}

// Optimized movement functions with cooldown
function moveLeft(){ 
    if(!falling || paused || gameOver) return; 
    const now = Date.now();
    if(now - lastMoveTime < MOVE_COOLDOWN) return;
    
    const {row,col,val} = falling;
    if(col>0 && grid[row][col-1]===0){ 
        grid[row][col]=0; 
        grid[row][col-1]=val; 
        falling.col--; 
        render(); 
        lastMoveTime = now;
        
        // Visual feedback
        const cell = getCellEl(row, falling.col);
        if(cell) {
            cell.style.transform = 'translateX(-2px)';
            setTimeout(() => {
                if(cell) cell.style.transform = 'translateX(0)';
            }, 100);
        }
    }
}

function moveRight(){ 
    if(!falling || paused || gameOver) return; 
    const now = Date.now();
    if(now - lastMoveTime < MOVE_COOLDOWN) return;
    
    const {row,col,val} = falling;
    if(col<COLS-1 && grid[row][col+1]===0){ 
        grid[row][col]=0; 
        grid[row][col+1]=val; 
        falling.col++; 
        render(); 
        lastMoveTime = now;
        
        // Visual feedback
        const cell = getCellEl(row, falling.col);
        if(cell) {
            cell.style.transform = 'translateX(2px)';
            setTimeout(() => {
                if(cell) cell.style.transform = 'translateX(0)';
            }, 100);
        }
    }
}

function hardDrop(){ 
    if(!falling || paused || gameOver) return;
    const {row,col} = falling;
    
    // Calculate drop distance for visual effect
    let dropDistance = 0;
    let testRow = row;
    while(testRow < ROWS-1 && grid[testRow+1][col] === 0) {
        dropDistance++;
        testRow++;
    }
    
    // Visual feedback for hard drop
    if(dropDistance > 0) {
        const cell = getCellEl(row, col);
        if(cell) {
            cell.style.transition = 'transform 0.2s ease';
            cell.style.transform = `translateY(${dropDistance * 10}px)`;
            setTimeout(() => {
                if(cell) cell.style.transform = 'translateY(0)';
            }, 200);
        }
    }
    
    while(falling && canMoveDown()) { 
        advanceFall(); 
    }
    if(falling) advanceFall();
}

/* ---------- IMPROVED KEY HANDLING ---------- */
function handleKeyPress(key) {
    if(gameOver || paused) return;
    
    const now = Date.now();
    if(now - lastMoveTime < MOVE_COOLDOWN) return;
    
    switch(key) {
        case 'ArrowLeft':
            moveLeft();
            break;
        case 'ArrowRight':
            moveRight();
            break;
        case 'ArrowDown':
            advanceFall();
            break;
        case 'Enter':
            hardDrop();
            break;
    }
}

// Track key states for responsive holding
document.addEventListener('keydown', (ev)=>{
    if(gameOver) return;
    
    if(['ArrowLeft','ArrowRight','ArrowDown','Enter',' '].includes(ev.key)) {
        ev.preventDefault();
        
        if(ev.key === ' ') {
            paused = !paused; 
            pauseBtn.textContent = paused ? 'Resume' : 'Pause';
            return;
        }
        
        if(!keysPressed[ev.key]) {
            keysPressed[ev.key] = true;
            handleKeyPress(ev.key);
            
            // Auto-repeat for held keys
            clearInterval(keysPressed[ev.key + 'Interval']);
            keysPressed[ev.key + 'Interval'] = setInterval(() => {
                if(keysPressed[ev.key]) {
                    handleKeyPress(ev.key);
                }
            }, 150); // Repeat every 150ms when held
        }
    }
});

document.addEventListener('keyup', (ev)=>{
    if(['ArrowLeft','ArrowRight','ArrowDown','Enter'].includes(ev.key)) {
        keysPressed[ev.key] = false;
        clearInterval(keysPressed[ev.key + 'Interval']);
    }
});

// Also improve button click responsiveness
leftBtn.addEventListener('click', ()=>{ 
    if(!paused && !gameOver) {
        moveLeft();
        // Button press feedback
        leftBtn.style.transform = 'scale(0.95)';
        setTimeout(() => leftBtn.style.transform = 'scale(1)', 100);
    }
});
rightBtn.addEventListener('click', ()=>{ 
    if(!paused && !gameOver) {
        moveRight();
        rightBtn.style.transform = 'scale(0.95)';
        setTimeout(() => rightBtn.style.transform = 'scale(1)', 100);
    }
});
downBtn.addEventListener('click', ()=>{ 
    if(!paused && !gameOver) {
        advanceFall();
        downBtn.style.transform = 'scale(0.95)';
        setTimeout(() => downBtn.style.transform = 'scale(1)', 100);
    }
});
hardBtn.addEventListener('click', ()=>{ 
    if(!paused && !gameOver) {
        hardDrop();
        hardBtn.style.transform = 'scale(0.95)';
        setTimeout(() => hardBtn.style.transform = 'scale(1)', 100);
    }
});

/* ---------- MERGE: SUM ALL CLUSTER MEMBERS ---------- */
function neighbors(r, c) {
  return [[r-1, c], [r+1, c], [r, c-1], [r, c+1]].filter(([rr, cc]) => rr >= 0 && rr < ROWS && cc >= 0 && cc < COLS);
}

function collectCluster(sr, sc, val, visited) {
  const stack = [[sr, sc]];
  const cluster = [];
  visited[sr][sc] = true;
  while (stack.length) {
    const [r, c] = stack.pop();
    cluster.push([r, c]);
    for (const [rr, cc] of neighbors(r, c)) {
      if (!visited[rr][cc] && grid[rr][cc] === val) {
        visited[rr][cc] = true;
        stack.push([rr, cc]);
      }
    }
  }
  return cluster;
}

// Function to create particle effect
function createParticleEffect(destR, destC) {
  const tileEl = getCellEl(destR, destC);
  if (!tileEl) return;

  const rect = tileEl.getBoundingClientRect();
  const particleCount = 8; // Number of particles
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    // Position particles at the center of the tile
    particle.style.left = `${rect.left + rect.width / 2}px`;
    particle.style.top = `${rect.top + rect.height / 2}px`;
    document.body.appendChild(particle);

    // Randomize particle trajectory
    const angle = Math.random() * 2 * Math.PI;
    const distance = 50 + Math.random() * 50; // Random distance 50-100px
    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);

    // Remove particle after animation
    setTimeout(() => particle.remove(), 600);
  }
}

async function processLand(lastR, lastC) {
  // Repeatedly detect clusters and merge until stable
  do {
    let mergedThisRound = false;
    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const val = grid[r][c];
        if (val === 0 || visited[r][c]) continue;
        const cluster = collectCluster(r, c, val, visited);
        if (cluster.length >= 2) {
          // Merge cluster into one tile with value val * 2^(cluster.length - 1)
          mergedThisRound = true;
          // Choose destination: lowest row, then rightmost
          cluster.sort((a, b) => (b[0] - a[0]) || (b[1] - a[1]));
          const [destR, destC] = cluster[0];
          for (const [rr, cc] of cluster) grid[rr][cc] = 0;
          const newVal = val * Math.pow(2, cluster.length - 1); // Chained merge
          grid[destR][destC] = newVal;
          score += newVal;
          if (newVal > bestTile) bestTile = newVal;
          // Visual effects
          const destEl = getCellEl(destR, destC);
          if (destEl) {
            // Apply pop and glow effects
            destEl.classList.add('pop', 'glow');
            setTimeout(() => destEl.classList.remove('pop', 'glow'), 600);
            // Create particle effect
            createParticleEffect(destR, destC);
          }
          playMergeSound();
          updateUI();
          render();
          // Small pause so player sees the merge chain
          await wait(110);
        }
      }
    }
    if (mergedThisRound) {
      // Apply gravity and continue scanning
      applyGravitySync();
      render();
      await wait(120);
      // Loop and re-scan for new merges
    } else break;
  } while (true);


  // After merging done, check game over condition:
  // 1) if top row is fully occupied -> game over
  // 2) if the tile that just landed was on row 0 AND that column's tile is blocked below (meaning it touches top boundary) -> game over
  if(grid[0].every(x => x !== 0)){ endGame(); return; }
  if(lastR === 0){
    if(grid[0][lastC] !== 0 && ROWS > 1 && grid[1][lastC] !== 0){ endGame(); return; }
  }
  // otherwise spawn next falling tile
  if(!gameOver) spawnFalling();
}

/* gravity blocking sync */
function applyGravitySync(){
  let moved;
  do {
    moved = false;
    for(let r=ROWS-2; r>=0; r--){
      for(let c=0;c<COLS;c++){
        if(grid[r][c] !== 0 && grid[r+1][c] === 0){
          grid[r+1][c] = grid[r][c]; grid[r][c] = 0; moved = true;
        }
      }
    }
  } while(moved);
}

/* ---------- GAME CONTROL ---------- */
function startFallTimer(){ stopFallTimer(); fallTimer = setInterval(()=>{ if(!paused && !gameOver) advanceFall(); }, speed); }
function stopFallTimer(){ if(fallTimer) clearInterval(fallTimer); fallTimer = null; }
function updateUI(){ scoreEl.textContent = score; bestEl.textContent = bestTile; level = 1 + Math.floor(score / LEVEL_SCORE_STEP); levelEl.textContent = level;
	//speed = Math.max(100, BASE_SPEED - (level-1) * 60); startFallTimer(); 
	speed = BASE_SPEED;
}
function endGame(){ gameOver = true; stopFallTimer(); updateUI(); playGameOver(); setTimeout(()=> alert(`Game Over\nScore: ${score}\nBest tile: ${bestTile}`), 60); }
function restart(){ 
  stopFallTimer(); 
  resetGrid(); 
  buildBoardUI(); 
  render(); 
  score = 0; 
  bestTile = 2; 
  level = 1; 
  speed = BASE_SPEED; 
  paused = false; 
  gameOver = false; 
  nextTile = null; 
  tileCooldowns = {}; // Reset cooldowns on restart
  updateAvailableTiles(); 
  spawnNextTile(); 
  spawnFalling(); 
  updateUI(); 
  startFallTimer(); 
}

/* ---------- UTILS ---------- */
function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

/* ---------- EVENTS ---------- */
leftBtn.addEventListener('click', ()=>{ moveLeft(); });
rightBtn.addEventListener('click', ()=>{ moveRight(); });
downBtn.addEventListener('click', ()=>{ advanceFall(); });
hardBtn.addEventListener('click', ()=>{ hardDrop(); });
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
restartBtn.addEventListener('click', ()=>{ restart(); });
themeSelector.addEventListener('change', (e)=>{ appEl.classList.remove('theme-darkneon','theme-light','theme-pastel'); appEl.classList.add(e.target.value==='light'?'theme-light': e.target.value==='pastel'?'theme-pastel':'theme-darkneon'); });
soundToggle.addEventListener('change', (e)=>{ soundEnabled = e.target.checked; if(soundEnabled) ensureAudio(); });

document.addEventListener('keydown', (ev)=>{
  if(gameOver) return;
  if(ev.key === 'ArrowLeft'){ ev.preventDefault(); moveLeft(); }
  else if(ev.key === 'ArrowRight'){ ev.preventDefault(); moveRight(); }
  else if(ev.key === 'ArrowDown'){ ev.preventDefault(); advanceFall(); }
  else if(ev.key === ' '){ ev.preventDefault(); paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
  else if(ev.key === 'Enter'){ ev.preventDefault(); hardDrop(); }
});

/* ---------- INIT ---------- */
function init(){
  resetGrid(); 
  buildBoardUI(); 
  updateLegend(); 
  render(); 
  updateAvailableTiles(); 
  spawnNextTile(); 
  spawnFalling(); 
  updateUI(); 
  startFallTimer();
}
init();
</script>
</body>
</html>